#ifdef PICNIC_INSTANCE

#include "picnic.h"
#include "endian_compat.h"

#include <string.h>

int
crypto_sign_keypair(unsigned char *pk, unsigned char *sk) {
  size_t sk_size = PICNIC_PRIVATE_KEY_SIZE(PICNIC_INSTANCE);
  size_t pk_size = PICNIC_PUBLIC_KEY_SIZE(PICNIC_INSTANCE);

  if (!picnic_create_key(PICNIC_INSTANCE, sk, &sk_size, pk, &pk_size)) {
    return -1;
  }

  // store public key in secret key
  memcpy(sk + 1 + LOWMC_BLOCK_SIZE(PICNIC_INSTANCE), pk, pk_size);

  return 0;
}

int
crypto_sign(unsigned char *sm, unsigned long long *smlen,
            const unsigned char *m, unsigned long long mlen,
            const unsigned char *sk) {

  size_t signature_len = PICNIC_SIGNATURE_SIZE(PICNIC_INSTANCE);
  uint32_t len = 0;

  const uint8_t* pk = sk + 1 + LOWMC_BLOCK_SIZE(PICNIC_INSTANCE);

  if (!picnic_sign(sk, 1 + LOWMC_BLOCK_SIZE(PICNIC_INSTANCE), pk, PICNIC_PUBLIC_KEY_SIZE(PICNIC_INSTANCE), m, mlen, sm + sizeof(len) + mlen, &signature_len)) {
    return -1;
  }

  len = htole32(signature_len);
  *smlen = sizeof(len) + mlen + signature_len;
  memmove(sm + sizeof(len), m, mlen);
  memcpy(sm, &len, sizeof(len));

  return 0;
}

int
crypto_sign_open(unsigned char *m, unsigned long long *mlen,
                 const unsigned char *sm, unsigned long long smlen,
                 const unsigned char *pk) {
  uint32_t signature_len;
  memcpy(&signature_len, sm, sizeof(signature_len));
  signature_len = le32toh(signature_len);

  if (signature_len + sizeof(signature_len) > smlen) {
    return -2;
  }

  const size_t message_len = smlen - signature_len - sizeof(signature_len);
  const uint8_t* message = sm + sizeof(signature_len);
  const uint8_t* sig = sm + sizeof(signature_len) + message_len;

 if (!picnic_verify(pk, PICNIC_PUBLIC_KEY_SIZE(PICNIC_INSTANCE), message, message_len, sig, signature_len)) {
   return -1;
 }

 memmove(m, message, message_len);
 *mlen = message_len;

 return 0;
}

#endif
